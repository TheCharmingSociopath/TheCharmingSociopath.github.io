---
title: Introduction to Quantum Computing for Software Engineers.
tags: [Quantum]
style: default
color: primary
description: An introductory article on quantum computing for the sweet summer children. I try to tell you more than just "0 and 1 at the same time" and try to avoid math wherever possible. This is an adaptation of a talk I gave to my collegues at work during my short stint as a software engineer.
date: 29-07-2021
updated: 29-07-2021
---

In this post we explain how quantum computing is a analogous to classical (probabilistic) computation. This exposition is meant for people who understand how basic computing works (after your standard algorithms and data structure course) don't know much about quantum computing. We will begin by answering the question: 
**what is computation?** What are the logical building blocks necessary for a programmable computer. 
Then we will study **quantum mechanics as a generalization of classical probability theory**, i.e., how do the axioms of quantum mechanics provide us with the above building blocks.

## What is Computation?

How do we use a computer to solve a problem?
Suppose the problem is that of adding two numbers, and imagine access to a physcial system whose initial state and the manner of evolution can be controlled (*programmed*) by us. 
Given this ability, we may be clever (and often lucky) enough to be able to program the evolution of the system such that if we map the two numbers we want to add to a state of the system, and let it evolve through the directed path for some time, the final state would be a mapping of the sum of the two numbers. This is how ancient mechanical (and mordern digital) computers function.

Observe that we need the following.
- A problem definition and a programmable system (a computer). 
- A way to map (input) the problems into the initial state of the computer. 
- A way to program the evolution of the system (an algorithm). 
- A way to read out the results (measure the final state of the computer, which is mapped to an output). 

The computers that you and I are used to are 'classical computers'. They are governed by the laws of classical physics (Newton's laws, etc.)
What we can input to them, and what we can program them to do is coverned by classical laws, since the evolution and the state space of the system is directed by those laws. 
But we now know that the world around us is actually governed by the laws of Quantum Mechanics. We can therefore try to build a programable machine governed by the laws of quantum mechanics. The possible input and output to the system, and the possible evolution of the system will both be governed by quantum mechanics. That is what we would call a 'quantum computers'. Quantum mechanics allows us to build [correlations](https://en.wikipedia.org/wiki/Correlation) that are not possible classically, which is the source of much of the (folklore) [quantum advantage](https://en.wikipedia.org/wiki/Quantum_supremacy). In the next section we will learn just enough quantum mechanics to be able to do the above four things, and work with a quantum computer. 

## Quantum Mechanics From Classical Probability Theory

**Classical probabilities.** Consider a biased coin that when tossed can land in either heads or tails with probability $p_1$ and $p_2$ respectively. From the axioms of probability, we know that $p_1, p_2 \geq 0$ and $p_1 + p_2 = 1$. We can represent the probability distribution as a [stochastic vector](https://en.wikipedia.org/wiki/Probability_vector) 
$$
\bar{p} := \begin{pmatrix}
p_1 \\
p_2 \end{pmatrix}.
$$
If we have two coins instead of one, the configuration space of a toss changes to head-head, head-tails, and so on. In this case, the probability distribution on the configuration space can be described by a 4-dimentional stochastic vector. Similarly, if we have larger, $n$-configuration space, the probability distribution on that configuration space can be described by a $n$ dimentional stochastic vector. 

Now suppose we bias the coin. For example, tamper with it such that the probability of heads reduces. How do we model this action mathematically? The head-tail probability distribution of the new coin can still be represented by a stochastic vector. It has been transformed into a new vector $$\bar{p'} := \begin{pmatrix} p_1' \\
p_2' \end{pmatrix}$$ such that $$p_1' < p_2'$$, but we still have $$p_1' + p_2' = 1$$ (since the new distribution should be a valid probability distribution). We have transformed one stochastic vector to another, and this transformation is represented by a [stochastic matrix](https://en.wikipedia.org/wiki/Stochastic_matrix) (an operator on the vector space that maps a stochastic vector to another). 

In classical computers, the basic unit of computation is a bit. It is a classical object whose state can be described by a 2-dimentional stochastic vector. In deterministic scenarios the bit is described by a 2D vector, one of whose entries is 1. In probabilistic scenarios (randomized algorithms), a bit is described by some 2D stochastic vector. Analogously on quantum computers the basic unit on computation is a **qubit**. It is a quantum object (an object governed by the laws of qunatum mechanics), and its state is described by a 2D vector [1]
$$
\psi := \begin{pmatrix}
a_0 \\
a_1 \end{pmatrix}
$$
such that $a_i \in \mathbb{C}$ and $\lVert a_0 \rVert^2 + \lVert a_1\rVert^2 = 1$ [2]. Here $a_i$ is the so called *probability amplitude* of the particular quantum state. Now consider the following [basis vectors](https://en.wikipedia.org/wiki/Basis_(linear_algebra)) of this 2D space: 
$$
\ket{0} := \begin{pmatrix}
1 \\ 
0
\end{pmatrix}, \ket{1} := \begin{pmatrix}
0 \\
1 
\end{pmatrix}.
$$

We'll call this the up and the down states, or the zero and the one state. They span the space of all possible qubit states. And thus an arbitrary qubit state can be written as $a_0 \ket{0} + a_1 \ket{1}$. When we  *observe the quantum state*, an act called *measurement* <sup><a href="#fn3" id="fn3ref" title="fn3">[3]</a></sup>, we get the state $\ket{0}$ with probability $\lVert a_0 \rVert^2$ and the state $\ket{1}$ with probability $\lVert a_1 \rVert^2$. This phenomenon is called superposition, and the qubits state is said to be superposed between $\ket{0}$ and $\ket{1}$. You might have heard that quantum computing is powerful because you can represent all states (all possible inputs to an algorithm) in superposition and run computation on all inputs at once, but note that the act of measurement will **collapse** the qubit into one of the basis states, giving only one output. Thus, this presents a limitation to what can be done with a quantum computer, not commonly acknowledged in popular media.

We now know how to represent one qubit, and how to read out th\rVert result (measure). Next we need to learn how to represent multiple qubits, and how to transform qubits in the state space. To represent more than one quantum state together, we use a operation called tensor product ($\otimes$). For two 2D vectors, the operation is defined as follows. 

$$
\begin{pmatrix}
a \\
b 
\end{pmatrix} \otimes \begin{pmatrix} c \otimes d \end{pmatrix}
= \begin{pmatrix} 
a \begin{pmatrix} c \\ d \end{pmatrix} \\
b \begin{pmatrix} c \\ d \end{pmatrix}
\end{pmatrix}
= \begin{pmatrix} ac \\ ad \\ bc \\ bd \end{pmatrix}.
$$ 

Thus for two qubits, the (linear combinaiton of the) following four (basis) states are possible: 

$$
\ket{00} = \ket{0} \otimes \ket{0} = (1 0 0 0)^T \\
\ket{01} = \ket{0} \otimes \ket{1} = (0 1 0 0)^T  \\
\ket{10} = \ket{1} \otimes \ket{0} = (0 0 1 0)^T  \\
\ket{11} = \ket{1} \otimes \ket{1} = (0 0 0 1)^T. 
$$

As an exercise, think about what is the probability of seeing each of the four basis states on meauring the state 
$$
\ket{\psi} := \begin{pmatrix} 0.5 \\ 0.5 \\ 0.5 \\ 0.5 \end{pmatrix}?
$$

It's 0.25 for each basis state. Note that the state of a $n$-qubit system is described by using a $2^n$D vector. Now let's discuss how the state evolves with time. Just as in classical theory, we need operations that map quantum states to quantum states (analogous to Stochastic matrices mapping stochastic vectors to stochastic vectors). The matrices that descibe quantum evolution are [Unitary matrices](https://en.wikipedia.org/wiki/Unitary_matrix). These are matrices that preserve [norms](https://en.wikipedia.org/wiki/Norm_(mathematics)), and thus also preserve probability amplitudes. Thus the total probability always remains 1. 

For qubits, an arbitrary quantum state can be represented as $\ket{\psi} := a_0 \ket{0} + a_1 \ket{1}$. Let's try and visualize all possible quantum states. We know that the 2-norm of the state has to be one, $\lVert a_0\rVert^2 + \lVert a_1\rVert^2 = 1$. Since $a_j$ is a complex number, we can write it using two real parameters $r_j$ and $\theta_j$ as $a_j := r_j e^{i\theta_j}$. But since we also know that the norm of the vector has to be 1, we can eliminate 1 parameter. Thus the geometry turns out to be that of a sphere, commonly called [Bloch Sphere](https://en.wikipedia.org/wiki/Bloch_sphere), and a quantum transformation on a qubit rotates a unit vector on a sphere. Next we will look at some commonly used quantum operators.

<img src="assets/qc-intro/bloch_sphere.png" alt="Bloch Sphere" width="200"/>

##### Pauli X, Y and Z Gates

These are defined as follows. 

$$
\sigma_z := \begin{pmatrix} 1 & 0 \\ 0 & -1 \end{pmatrix}, \sigma_x := \begin{pmatrix} 0 & 1 \\ 1 & 0 \end{pmatrix}, \sigma_y := \begin{pmatrix} 0 & -i \\ i & 0 \end{pmatrix}.
$$

##### Hadamard Gate

$$
H := \frac{1}{2} \begin{pmatrix} 1 & 1 \\ 1 & -1 \end{pmatrix}
$$

##### CNOT (Controlled NOT) Gate

$$
CNOT := \begin{pmatrix}
1 & 0 & 0 & 0 \\ 
0 & 1 & 0 & 0 \\ 
0 & 0 & 0 & 1 \\ 
0 & 0 & 1 & 0 \\ 
\end{pmatrix}
$$

### Quantum Circuit

Magic states, distillation and errror correction, wrt applicatoin of clifford + T gates. 



[1] Quantum computer scientists like to waste chalk a lot, and this they use this weird $\ket{.}$ notation to represent a vector, and call it the [bra-ket](https://en.wikipedia.org/wiki/Bra%E2%80%93ket_notation1) notation (pronounced braket).

[2] Apologies to the mathematicians and physicists out there who know that this is not *technically* correct. Only pure quantum states can be descibed in this manner. For a more mathematical exposition, refer to the excellent [lecture series](https://www.youtube.com/playlist?list=PLPH7f_7ZlzxQVx5jRjbfRGEzWY_upS5K6) by Prof. Frederic Schuller that covers the axioms of quantum mechanics mathematically and is very accessable. 

<a name="fn3">[3]</a>The act of measurement also requires us to specify a basis in which to measure the qubit. For details see the lecture series mentioned above. In this post, whenever we say measure, we mean measure in the ${\ket{0}, \ket{1}}$ basis. <a href="#fn3ref" title="Return to footnote 3 in the text.">↩</a></p>


